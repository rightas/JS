<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h2>3.1 垃圾回收算法</h2>
    <div>
        V8的垃圾回收算法主要基于分代式垃圾回收机制，在早期的垃圾回收中，
        人们发现没有一种算法能够胜任所有的场景，因为在实际应用中，对象的生存周期长短不一，
        不同的算法只能针对特定的情况发挥作用。因此，在现代的垃圾回收算法中，
        根据对象的存活时间将垃圾回收进行了不同分代，主要分为新生代和老生代，
        然后对不用分代的内存使用不用的算法。
    </div>
    <h2>3.2 避免内存泄漏</h2>
    <h4>3.2.1 少用闭包</h4>
    <div>少用闭包我们知道，作用域链上的对象访问只能向上，这样外部无法向内部访问，
        在JavaScript中，实现外部作用域访问内部作用域中的变量的方法就叫做闭包，
        这得益于高阶函数的特性：函数可以作为参数或者返回值
    </div>
    <h4>3.2.2 少创建全局变量</h4>
    <div>
        在ES5中以，var声明的方式在全局作用域中创建一个变量时，或者在函数作用域中
        不以任何声明的方式创建一个变量时，都会无形地挂载到window全局对象上。当进行
        垃圾回收时，在标记阶段因为window对象可以作为根节点，在window上挂载的属性均
        可以被访问到，并将其标记为活动的常驻内存，因此也就不会被垃圾回收，只有在整个
        进程退出时全局作用域才会被销毁。如果你遇到需要必须使用全局变量的场景，那么请
        保证一定要在全局变量使用完毕后将其设置为null，从而触发回收机制
    </div>
    <h4>3.2.3 手动清除定时器</h4>
    <div>
        在我们的应用中经常会有使用setTimeout或者setInterval等定时器的场景，
        定时器本身是一个非常有用的功能，但是如果我们稍不注意，忘记在适当的时间手动
        清除定时器，那么很有可能就会导致内存泄漏，正确的做法是，在定时器完成的时候，
        手动清除：
    </div>
    <h4>3.2.4 手动清除事件监听器</h4>
    <div>
        removeEventListener()方法用于移除由addEventListener()方法添加的事件句柄
        ，在组件销毁时移除事件处理函数，以减少内存泄漏，提高应用性能：
    </div>
    <h4>3.2.5 养成清理log的好习惯</h4>
    <div>
        通过前几个示例我们会发现如果我们一旦疏忽，就会容易地引发内存泄漏的问题，
        除此之外，其实大量的console.log也会引起内存泄漏的问题，在生产环境中，
        我们应该清除大多数非必要的console，不清除的话会比较耗性能。如果是调用一两
        次就没什么，万一放到了循环里就很过分了
    </div>
    

</body>
</html>